<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VipCoringa | Monitor de Views com PrevisÃ£o</title>
    <!-- Inclui Tailwind CSS para estilizaÃ§Ã£o rÃ¡pida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carrega a fonte 'Fira Code' do Google Fonts, ideal para exibiÃ§Ã£o tipo terminal -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* Define a fonte padrÃ£o para o corpo e a cor de fundo */
        body {
            font-family: 'Fira Code', monospace; /* Fira Code Ã© uma fonte monoespaÃ§ada, ideal para terminal */
            background-color: #0a0a0a; /* Fundo preto escuro */
        }
        /* Estilos para a caixa do terminal, adicionando uma sombra azul sutil */
        .terminal {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        /* Estilos para o cabeÃ§alho do terminal */
        .terminal-header {
            height: 30px; /* Altura fixa do cabeÃ§alho */
            border-top-left-radius: 0.5rem; /* Cantos arredondados */
            border-top-right-radius: 0.5rem; /* Cantos arredondados */
        }
        /* Estilos para os pontos de controle (vermelho, amarelo, verde) no cabeÃ§alho, simulando botÃµes de janela */
        .terminal-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%; /* CÃ­rculos perfeitos */
            margin-right: 6px;
        }
        /* Estilos para a Ã¡rea de conteÃºdo do terminal, com uma sombra interna para profundidade */
        .terminal-content {
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        /* AnimaÃ§Ã£o de piscar para o cursor no carregamento */
        .blink {
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 bg-gray-900 text-gray-100">
    <!-- TÃ­tulo principal da pÃ¡gina, centralizado e com cores destacadas -->
    <div class="w-full max-w-4xl mx-auto mb-6">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-blue-400 font-mono">
            VipCoringa <span class="text-gray-400">|</span> <span class="text-gray-300">Monitor de Views com PrevisÃ£o</span>
        </h1>
    </div>

    <!-- SeÃ§Ã£o de Input para a PrevisÃ£o de VisualizaÃ§Ãµes -->
    <div class="w-full max-w-4xl mx-auto mb-6 p-4 bg-gray-800 rounded-lg border border-gray-700 shadow-md">
        <h2 class="text-xl font-bold text-blue-300 mb-4 text-center">PrevisÃ£o de VisualizaÃ§Ãµes</h2>
        <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
            <input
                type="number"
                id="targetViewsInput"
                placeholder="Views alvo (ex: 1000000)"
                class="w-full sm:w-auto flex-grow px-4 py-2 rounded-md bg-gray-700 text-gray-100 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                min="0"
            />
            <button
                id="startAnalysisButton"
                class="w-full sm:w-auto px-6 py-2 rounded-md bg-blue-600 hover:bg-blue-700 transition duration-300 text-white font-bold focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900"
            >
                Iniciar AnÃ¡lise
            </button>
        </div>
    </div>

    <!-- ContÃªiner principal do terminal, simulando uma janela de console -->
    <div class="terminal w-full max-w-4xl rounded-lg overflow-hidden border border-gray-700">
        <!-- CabeÃ§alho do terminal com os botÃµes de controle e o endereÃ§o da fonte de dados -->
        <div class="terminal-header bg-gray-800 flex items-center px-4">
            <div class="terminal-dot bg-red-500"></div>
            <div class="terminal-dot bg-yellow-500"></div>
            <div class="terminal-dot bg-green-500"></div>
            <!-- Exibe a URL da API, informando que um proxy CORS estÃ¡ sendo usado -->
            <span class="text-xs ml-4 text-gray-400 hidden sm:inline">https://komarev.com/ghpvc/ (Via CORS Proxy)</span>
        </div>
        
        <!-- Ãrea de conteÃºdo onde o painel formatado serÃ¡ exibido -->
        <div class="terminal-content bg-black p-4 md:p-6 overflow-auto max-h-[70vh]">
            <pre class="text-sm md:text-base text-green-100 font-mono whitespace-pre-wrap" id="api-content">
Carregando dados do monitor... <span class="blink">|</span>
            </pre>
        </div>
        
        <!-- RodapÃ© do terminal com informaÃ§Ãµes de status e Ãºltima atualizaÃ§Ã£o -->
        <div class="bg-gray-900 text-xs text-gray-500 p-2 flex justify-between items-center">
            <div>
                <span class="hidden sm:inline">Terminal</span> 
                <span class="inline sm:hidden">VipCoringa</span>
            </div>
            <div>
                <span id="last-update">Ãšltima atualizaÃ§Ã£o: --:--:--</span>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================================================
        // ATENÃ‡ÃƒO: USO DE PROXY PÃšBLICO CORS
        // Esta Ã© a soluÃ§Ã£o para fazer a requisiÃ§Ã£o funcionar no GitHub Pages,
        // contornando o erro de CORS (Cross-Origin Resource Sharing) que a API komarev.com nÃ£o permite.
        // NO ENTANTO, proxies pÃºblicos NÃƒO SÃƒO RECOMENDADOS PARA USO EM PRODUÃ‡ÃƒO devido a:
        // - Confiabilidade: Podem sair do ar a qualquer momento.
        // - Limites de Uso: Podem bloquear suas requisiÃ§Ãµes se houver muitas.
        // - SeguranÃ§a: Seus dados passam por um servidor de terceiros.
        // A MELHOR SOLUÃ‡ÃƒO AINDA Ã‰ TER UM BACKEND PRÃ“PRIO (como na Vercel Functions) ou que a API de destino permita CORS.
        // ============================================================================================================

        // URL da API komarev.com que retorna as views em formato SVG.
        const originalKomarevApiUrl = 'https://komarev.com/ghpvc/?username=VipCoringa&style=for-the-badge&label=Views:&color=gray';
        
        // URL do proxy CORS pÃºblico, concatenado com a URL da API real.
        const komarevApiUrl = `https://corsproxy.io/?${encodeURIComponent(originalKomarevApiUrl)}`;
        
        const USERNAME = 'VipCoringa'; // Seu nome de usuÃ¡rio para o monitor
        const ARROW = 'â‡§'; // Caractere de seta para indicar status de subida

        // ReferÃªncias aos elementos do DOM
        const contentElement = document.getElementById('api-content');
        const lastUpdateElement = document.getElementById('last-update');
        const targetViewsInput = document.getElementById('targetViewsInput');
        const startAnalysisButton = document.getElementById('startAnalysisButton');

        // VariÃ¡veis de estado do monitor e previsÃ£o
        let currentViews = 0; // Armazena o nÃºmero de views atual
        let targetViews = 0; // Armazena a meta de views do usuÃ¡rio
        let initialViews = 0; // Views no inÃ­cio da anÃ¡lise de 1 minuto
        let analysisStartTime = null; // Timestamp do inÃ­cio da anÃ¡lise
        let viewRatePerSecond = 0; // Taxa de views por segundo (views/segundo)
        let isAnalyzing = false; // Flag para indicar se a anÃ¡lise estÃ¡ em andamento
        let analysisTimeoutId = null; // ID do timeout para a anÃ¡lise de 1 minuto

        /**
         * ObtÃ©m a hora atual formatada, garantindo o fuso horÃ¡rio correto (SÃ£o Paulo).
         * @returns {string} A hora atual no formato HH:MM:SS.
         */
        function getHora() {
            return new Date().toLocaleTimeString('pt-BR', { hour12: false, timeZone: 'America/Sao_Paulo' });
        }

        /**
         * ObtÃ©m a data e hora formatadas.
         * @param {Date} date - Objeto Date a ser formatado.
         * @returns {string} A data e hora no formato DD/MM/YYYY HH:MM:SS.
         */
        function formatDateTime(date) {
            return date.toLocaleDateString('pt-BR', { timeZone: 'America/Sao_Paulo' }) + ' ' +
                   date.toLocaleTimeString('pt-BR', { hour12: false, timeZone: 'America/Sao_Paulo' });
        }

        /**
         * ConstrÃ³i o painel de texto formatado para exibiÃ§Ã£o no terminal.
         * Reintroduz os caracteres estilizados como solicitado.
         * @param {string} views - O nÃºmero de views formatado como string.
         * @param {string} status - O status atual do monitor.
         * @param {string} hora - A hora atual formatada.
         * @param {number} currentViewsNum - O nÃºmero de views atual em formato numÃ©rico.
         * @returns {string} O painel de texto formatado.
         */
        function buildPanel(views, status, hora, currentViewsNum) {
            let predictionInfo = '';
            // Se uma anÃ¡lise estiver em andamento, mostra o tempo restante para o fim da anÃ¡lise
            if (isAnalyzing) {
                const elapsed = (Date.now() - analysisStartTime) / 1000; // Tempo decorrido em segundos
                const remaining = Math.max(0, 60 - Math.floor(elapsed)); // Tempo restante (mÃ­nimo 0)
                predictionInfo = `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ğ™°ğ™½ğ™°Ìğ™»ğ™¸ğš‚ğ™´: ${remaining.toString().padStart(2, '0')} ğšœğšğšğšğš—ğšğš˜ğšœ ğš›ğšğšœğšğšŠğš—ğšğšğšœ â•‘
`.trim();
            } else if (targetViews > 0 && viewRatePerSecond > 0 && currentViewsNum < targetViews) {
                // Se a anÃ¡lise terminou e hÃ¡ uma taxa de views vÃ¡lida, mostra a previsÃ£o
                const remainingViews = targetViews - currentViewsNum; // Views que faltam para a meta
                const timeNeededInSeconds = remainingViews / viewRatePerSecond; // Tempo necessÃ¡rio em segundos
                
                const completionDate = new Date(Date.now() + timeNeededInSeconds * 1000); // Data e hora da conclusÃ£o
                const formattedCompletion = formatDateTime(completionDate); // Formata para exibiÃ§Ã£o

                predictionInfo = `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ğš…ğ™¸ğ™´ğš†ğš‚ ğ™°ğ™»ğš…ğ™¾ : ${targetViews.toLocaleString('pt-BR').padEnd(15)}â•‘
â•‘ ğ™¿ğšğ™´ğš…ğ™¸ğš‚ğ™°Ìƒğ™¾  : ${formattedCompletion.padEnd(15)}â•‘
`.trim();
            } else if (targetViews > 0 && viewRatePerSecond === 0 && !isAnalyzing) {
                // Se a anÃ¡lise terminou, mas a taxa Ã© zero (nenhuma view detectada)
                predictionInfo = `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ğš…ğ™¸ğ™´ğš†ğš‚ ğ™°ğ™»ğš…ğ™¾ : ${targetViews.toLocaleString('pt-BR').padEnd(15)}â•‘
â•‘ ğš‚ğšƒğ™°ğšƒğš„ğš‚    : ğš‚ğšğš– ğšŸğš’ğšğš ğšœ ğš—ğšŠ ğšŠğš—ğšŠÌğš•ğš’ğšœğš â•‘
`.trim();
            } else if (targetViews > 0 && currentViewsNum >= targetViews && !isAnalyzing) {
                // Se a meta jÃ¡ foi atingida
                 predictionInfo = `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ğš…ğ™¸ğ™´ğš†ğš‚ ğ™°ğ™»ğš…ğ™¾ : ${targetViews.toLocaleString('pt-BR').padEnd(15)}â•‘
â•‘ ğš‚ğšƒğ™°ğšƒğš„ğš‚    : ğ™¼ğ™´ğšƒğ™° ğ™°ğšƒğ™¸ğ™½ğ™¶ğ™¸ğ™³ğ™°! ğŸ‰ â•‘
`.trim();
            }

            // ConstrÃ³i o painel principal com os dados e informaÃ§Ãµes de previsÃ£o
            return `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğ™¼ğ™¾ğ™½ğ™¸ğšƒğ™¾ğš ğ™³ğ™´ ğš…ğ™¸ğ™´ğš†ğš‚       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ğš„ğšœğšğšŠÌğš›ğš’ğš˜: ${USERNAME.padEnd(20)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ğš…ğ™¸ğ™´ğš†ğš‚ ğ™°ğšƒğš„ğ™°ğ™¸ğš‚ : ${views.padEnd(15)}â•‘
â•‘ ğš‚ğšƒğ™°ğšƒğš„ğš‚       : ${status.padEnd(15)}â•‘
â•‘ ğ™·ğ™¾ğšğ™°Ìğšğ™¸ğ™¾      : ${hora.padEnd(15)}â•‘
${predictionInfo ? predictionInfo : ''}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`.trim();
        }

        /**
         * Inicia o processo de anÃ¡lise de 1 minuto para calcular a taxa de views.
         */
        function startAnalysis() {
            // Remove pontos de milhares do input e converte para nÃºmero inteiro
            const inputVal = parseInt(targetViewsInput.value.replace(/\./g, '')); 
            
            if (isNaN(inputVal) || inputVal <= 0) {
                contentElement.textContent = `[${getHora()}] Por favor, insira um nÃºmero de views alvo vÃ¡lido e positivo.`;
                return;
            }

            targetViews = inputVal; // Define a meta de views
            isAnalyzing = true; // Inicia o modo de anÃ¡lise
            initialViews = currentViews; // Captura as views atuais como ponto de partida
            analysisStartTime = Date.now(); // Marca o inÃ­cio da anÃ¡lise
            viewRatePerSecond = 0; // Reseta a taxa de views antes de iniciar a nova anÃ¡lise

            // Desabilita o input e o botÃ£o durante a anÃ¡lise para evitar alteraÃ§Ãµes
            startAnalysisButton.disabled = true;
            targetViewsInput.disabled = true;

            contentElement.textContent = `[${getHora()}] Iniciando anÃ¡lise de taxa de views para ${targetViews.toLocaleString('pt-BR')} views... Aguarde 1 minuto.`;
            
            // Define um timeout para encerrar a anÃ¡lise apÃ³s 1 minuto (60 segundos)
            analysisTimeoutId = setTimeout(endAnalysis, 60000);
        }

        /**
         * Encerra o processo de anÃ¡lise de 1 minuto e calcula a taxa de views.
         */
        function endAnalysis() {
            isAnalyzing = false; // Sai do modo de anÃ¡lise
            const finalViews = currentViews; // Captura as views ao final do minuto

            const viewsGained = finalViews - initialViews; // Views ganhas durante o minuto
            viewRatePerSecond = viewsGained / 60; // Views por segundo

            // Reabilita o input e o botÃ£o
            startAnalysisButton.disabled = false;
            targetViewsInput.disabled = false;

            let statusMessage = '';
            if (viewRatePerSecond > 0) {
                statusMessage = `Taxa calculada: ${viewRatePerSecond.toFixed(2)} views/segundo.`;
            } else {
                statusMessage = `Nenhuma view detectada durante a anÃ¡lise. Tente novamente!`;
            }
            console.log(`AnÃ¡lise concluÃ­da: ${statusMessage}`);
            // A prÃ³xima chamada de `fetchData` irÃ¡ atualizar o painel com a nova taxa.
        }

        /**
         * Busca o nÃºmero de views diretamente da API komarev.com (via proxy) e atualiza o painel.
         */
        async function fetchData() {
            try {
                // Faz a requisiÃ§Ã£o para o proxy CORS, que entÃ£o encaminha para a API komarev.com
                const response = await fetch(komarevApiUrl, { cache: 'no-store' });
                
                // Se a resposta do proxy nÃ£o for OK, algo deu errado (o proxy pode ter falhado ou a API).
                if (!response.ok) {
                    throw new Error(`Erro na requisiÃ§Ã£o (possivelmente proxy ou Komarev): ${response.status} ${response.statusText}`);
                }
                
                // A resposta Ã© um SVG, precisamos extrair o nÃºmero de views dele.
                const svgText = await response.text();
                // A expressÃ£o regular procura por 'aria-label="(?:[^"]*:: )?([0-9,]+)"' e captura o nÃºmero.
                const match = svgText.match(/aria-label="(?:[^"]*:: )?([0-9,]+)/);
                
                let viewsString = 'N/A';
                if (match && match[1]) {
                    viewsString = match[1]; // O nÃºmero de views encontrado (ex: "1,234,567")
                    currentViews = parseInt(viewsString.replace(/,/g, '')); // Converte para nÃºmero inteiro, removendo vÃ­rgulas
                } else {
                    console.warn('NÃ£o foi possÃ­vel extrair o nÃºmero de views do SVG.');
                    currentViews = 0;
                }

                const hora = getHora();
                let status = `${ARROW} ğš‚ğš„ğ™±ğ™¸ğ™½ğ™³ğ™¾`; // Status padrÃ£o
                
                // Ajusta o status dependendo do estado da anÃ¡lise ou da meta
                if (isAnalyzing) {
                    status = `ğ™°ğ™½ğ™°ğ™»ğ™¸ğš‚ğ™°ğ™½ğ™³ğ™¾...`;
                } else if (targetViews > 0 && currentViews >= targetViews) {
                    status = `ğ™¼ğ™´ğšƒğ™° ğ™°ğšƒğ™¸ğ™½ğ™¶ğ™¸ğ™³ğ™°!`;
                }


                // ConstrÃ³i o painel com os dados obtidos e informaÃ§Ãµes de previsÃ£o
                const painel = buildPanel(viewsString, status, hora, currentViews);
                contentElement.textContent = painel; // Atualiza o conteÃºdo do terminal
                
                updateDateTime(); // Atualiza o carimbo de data/hora da Ãºltima atualizaÃ§Ã£o
            } catch (error) {
                const errorTime = new Date().toLocaleTimeString('pt-BR', { timeZone: 'America/Sao_Paulo' });
                contentElement.textContent = `[${errorTime}] Erro ao carregar dados: ${error.message}\nVerifique o console para mais detalhes ou tente outro proxy CORS.`;
                console.error('Erro ao buscar dados:', error);
            }
        }

        /**
         * Atualiza a exibiÃ§Ã£o da data e hora da Ãºltima atualizaÃ§Ã£o no rodapÃ©.
         */
        function updateDateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('pt-BR', { timeZone: 'America/Sao_Paulo' });
            lastUpdateElement.textContent = `Ãšltima atualizaÃ§Ã£o: ${timeString}`;
        }

        // Adiciona o event listener para o botÃ£o de iniciar anÃ¡lise
        startAnalysisButton.addEventListener('click', startAnalysis);

        // Carrega os dados imediatamente ao iniciar e depois a cada 1 segundo
        fetchData();
        setInterval(fetchData, 1000);

        // Atualiza o horÃ¡rio da Ãºltima atualizaÃ§Ã£o no rodapÃ© a cada segundo para manter preciso
        updateDateTime();
        setInterval(updateDateTime, 1000);
    </script>
</body>
</html>

